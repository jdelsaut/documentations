#### Create migration with entity framework
```bash  
> dotnet ef migrations add InitialCreate -p .\ProjetAccompagnement.Infrastructure\ -s .\ProjetAccompagnement.Api\
```
 
#### Apply entity framework migrations
```bash  
> dotnet ef database update --project .\ProjetAccompagnement.Infrastructure\ --startup-project .\ProjetAccompagnement.Api\
 
### Microsoft
 
- [Microsoft.AspNetCore.Authentication.JwtBearer](https://github.com/dotnet/aspnetcore/tree/main/src/Security/Authentication/JwtBearer)
- [Microsoft.AspNetCore.Identity.EntityFrameworkCore](https://github.com/dotnet/aspnetcore/tree/main/src/Identity/EntityFrameworkCore)
- [Microsoft.EntityFrameworkCore](https://github.com/dotnet/efcore)
- [Microsoft.EntityFrameworkCore.Design](https://github.com/dotnet/efcore/tree/main/src/EFCore.Design)
- [Microsoft.EntityFrameworkCore.SqlServer](https://github.com/dotnet/efcore/tree/main/src/EFCore.SqlServer)
- [Microsoft.EntityFrameworkCore.Tools](https://github.com/dotnet/efcore/tree/main/src/EFCore.Tools)
- [Microsoft.VisualStudio.Web.CodeGeneration.Design](https://github.com/dotnet/aspnetcore/tree/main/src/Scaffolding/VisualStudio.Web.CodeGeneration.Design)
 
 
### Third party
 
- [Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)
- [Mapster](https://github.com/MapsterMapper/Mapster)
- [Mapster.DependencyInjection](https://github.com/MapsterMapper/Mapster.DependencyInjection)
  >A fast, fun and stimulating object to object Mapper 
- [MediatR](https://github.com/jbogard/MediatR)
-  [MediatR.Extensions.Microsoft.DependencyInjection](https://github.com/jbogard/MediatR.Extensions.Microsoft.DependencyInjection)
    > Simple mediator implementation in .NET
    In-process messaging with no dependencies.
    Supports request/response, commands, queries, notifications and events, synchronous and async with intelligent dispatching via C# generic variance.
- [FluentValidation](https://github.com/FluentValidation/FluentValidation) 
- [FluentValidation.AspNetCore](https://github.com/FluentValidation/FluentValidation.AspNetCore)
  > A popular .NET validation library for building strongly-typed validation rules. 
- [ErrorOr](https://github.com/ardalis/ErrorOr)
  >A simple, fluent discriminated union of an error or a result.
- [ardalis.smartenum](https://github.com/ardalis/smartenum) 
- >A base class for quickly and easily creating strongly typed enum replacements in C#. 
- [Polly](https://github.com/App-vNext/Polly)
  >Polly is a .NET resilience and transient-fault-handling library that allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner.
- [ReFit](https://github.com/reactiveui/refit)
  >The automatic type-safe REST library for .NET Core, Xamarin and .NET. Heavily inspired by Square's Retrofit library, Refit turns your REST API into a live interface.
 
### Testing
- [xUnit](https://github.com/xunit/xunit)
  > xUnit.net is a free, open source, community-focused unit testing tool for the .NET Framework.
- [Moq](https://github.com/devlooped/moq)
  > The most popular and friendly mocking framework for .NET
- [FluentAssertions](https://github.com/fluentassertions/fluentassertions)
  > Fluent API for asserting the results of unit tests that targets .NET Framework 4.5, 4.7, .NET Standard 1.3, 1.6 and 2.0. Supports the unit test frameworks MSTest, MSTest2, Gallio, NUnit, XUnit, MBUnit, MSpec, and NSpec.
- [TestContainers](https://github.com/testcontainers/testcontainers-dotnet)
  >Testcontainers is a .NET library that supports JUnit tests, providing lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container.
- [Respawn](https://github.com/jbogard/Respawn)
  > Intelligent database cleaner for integration tests in .NET
- [Bogus](https://github.com/bchavez/Bogus)
  > A simple and sane fake data generator for C#. Based on and ported from the famed faker.js.
 
 
 
/// <summary>
        /// Evaluate collaborateur rules.
        /// </summary>
        /// <param name="request">Evaluate request.</param>
        /// <param name="cancellationToken">Cancellation Token.</param>
        /// <returns>RuleResult.</returns>
        /// <response code="200">Returns evaluated rules.</response>
        /// <response code="401">Unauthorized.</response>
        /// <response code="404">the specified rule was not found. </response>
        /// <response code="500"></response>
        [HttpPost("evaluer")]
        [AllowAnonymous]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status401Unauthorized)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        [ProducesResponseType(StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> Evaluer(EvaluateRequest request, CancellationToken cancellationToken)
        {
            var ruleResultResponse = new List<RuleResultResponse>();
 
            var evaluateQuery = new EvaluateQuery(request.BeneficiaireId, request.Code);
            var evaluateResult = await _mediator.Send(evaluateQuery, cancellationToken);
 
            if (!evaluateResult.IsError)
            {
                // Get the rules result
                if (evaluateResult.Value.RulesNotPassed is null)
                {
                    ruleResultResponse.Add(new RuleResultResponse()
                    {
                        IsRulePassed = evaluateResult.Value.IsRulePassed,
                        ErrorMessage = evaluateResult.Value.ErrorMessage,
                        Value = evaluateResult.Value.Value,
                        CodeRule = evaluateResult.Value.CodeRule,
                    });
                }
                else
                {
                    // Get the rules not passed
                    evaluateResult.Value.RulesNotPassed!.ForEach(x =>
                        ruleResultResponse.Add(new RuleResultResponse()
                        {
                            IsRulePassed = x.IsRulePassed,
                            ErrorMessage = x.ErrorMessage,
                            Value = x.Value,
                            CodeRule = x.CodeRule,
                        }));
                }
            }
 
            // Dispatch the result or Error
            return evaluateResult.Match(
                _ => Ok(ruleResultResponse),
                Problem);
        }
 
        /// <summary>
        /// Get rules for beneficiaire.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>List of rules for Beneficiaire domaine.</returns>
        /// <response code="200">Returns list of collaborateurs rules.</response>
        /// <response code="401">Unauthorized.</response>
        /// <response code="500"></response>
        [HttpGet("rules")]
        [AllowAnonymous]
        [ProducesResponseType(StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status401Unauthorized)]
        [ProducesResponseType(StatusCodes.Status500InternalServerError)]
        public async Task<IActionResult> GetRules(CancellationToken cancellationToken)
        {
            var getRulesQuery = new GetRulesQuery();
            var rulesResult = await _mediator.Send(getRulesQuery, cancellationToken);
 
            return rulesResult.Match(
                rules => Ok(_mapper.Map<Dictionary<string, RuleDetailResponse>>(rules)),
                Problem);
        }
 
public static class DependencyInjection
{
    public static IServiceCollection AddCollaborateurSdk(
        this IServiceCollection services,
        Uri collaborateurApiUri)
    {
#pragma warning disable S4830 // Desactivation des certificats le temps d'update tous les certifcats - Server certificates should be verified during SSL/TLS connections
        services.AddRefitClient<ICollaborateurApi>()
            .ConfigureHttpClient(c => c.BaseAddress = collaborateurApiUri)
            .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler { ServerCertificateCustomValidationCallback = (_, _, _, _) => true })
            .AddStandardResilienceHandler(options =>
            {
                options.Retry.ConfigureRetry();
 
                // options.CircuitBreaker.ConfigureCircuitBreaker();
                // options.RateLimiter.ConfigureRateLimiter();
                // options.TotalRequestTimeout.ConfigureTotalRequestTimeout();
            });
#pragma warning restore S4830 // Server certificates should be verified during SSL/TLS connections
 
        return services;
    }
 
    public static void ConfigureRetry(this HttpRetryStrategyOptions options)
    {
        options.MaxRetryAttempts = 4;
        options.Delay = TimeSpan.FromSeconds(5);
        options.OnRetry = _ => default;
    }
 
    public static void ConfigureCircuitBreaker(this HttpCircuitBreakerStrategyOptions options)
    {
        options.BreakDuration = TimeSpan.FromSeconds(30);
    }
 
    public static void ConfigureRateLimiter(this HttpRateLimiterStrategyOptions options)
    {
        options.RateLimiter = _ => default;
    }
 
    public static void ConfigureTotalRequestTimeout(this HttpTimeoutStrategyOptions options)
    {
        options.Timeout = TimeSpan.FromSeconds(60);
        options.OnTimeout = _ => default;
    }
}
 
